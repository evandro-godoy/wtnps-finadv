"""
Dry-run script for WTNPS Trade Live Monitor.

Runs the system for a specified duration to validate:
- MT5 connection stability
- Model inference performance
- Signal generation
- Memory usage
- No unhandled exceptions

Usage:
    poetry run python scripts/dry_run.py --ticker WDO$ --duration 5
    poetry run python scripts/dry_run.py --ticker WIN$ --duration 10 --timeframe M5
"""

import sys
import argparse
import time
from pathlib import Path
from datetime import datetime
import logging
import psutil
import os

# Add project root to Python path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.live.monitor_engine import RealTimeMonitor

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s'
)
logger = logging.getLogger(__name__)


class DryRunMonitor:
    """Dry-run monitor for testing system stability."""
    
    def __init__(self, ticker: str, timeframe: str, duration_minutes: int):
        """
        Initialize dry-run monitor.
        
        Args:
            ticker: Asset ticker (e.g., "WDO$")
            timeframe: Timeframe string (e.g., "M5")
            duration_minutes: Duration to run in minutes
        """
        self.ticker = ticker
        self.timeframe = timeframe
        self.duration_minutes = duration_minutes
        self.start_time = None
        self.end_time = None
        
        # Stats
        self.signals_generated = 0
        self.exceptions_count = 0
        self.max_memory_mb = 0
        self.avg_memory_mb = 0
        self.memory_samples = []
        
        # Setup logging
        self._setup_logging()
    
    def _setup_logging(self):
        """Setup dry-run specific logging."""
        logs_dir = Path("reports")
        logs_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_path = logs_dir / f"dry_run_{timestamp}.log"
        
        # File handler
        file_handler = logging.FileHandler(self.log_path, encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        file_handler.setFormatter(
            logging.Formatter('%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
        )
        
        # Add handler to root logger
        logging.getLogger().addHandler(file_handler)
        
        logger.info(f"Dry-run logs will be saved to: {self.log_path}")
    
    def signal_callback(self, signal_data: dict):
        """
        Callback for signals generated by MonitorEngine.
        
        Args:
            signal_data: Signal data dictionary
        """
        self.signals_generated += 1
        
        signal_type = signal_data.get('type', 'UNKNOWN')
        message = signal_data.get('message', '')
        
        if signal_type == 'ALERT':
            logger.info(f"üö® ALERT: {message}")
        elif signal_type == 'INFO':
            logger.info(f"üìä INFO: {message}")
        else:
            logger.debug(f"TICK: {message}")
    
    def monitor_memory(self):
        """Monitor memory usage."""
        process = psutil.Process(os.getpid())
        memory_mb = process.memory_info().rss / (1024 ** 2)
        
        self.memory_samples.append(memory_mb)
        self.max_memory_mb = max(self.max_memory_mb, memory_mb)
        
        if len(self.memory_samples) > 0:
            self.avg_memory_mb = sum(self.memory_samples) / len(self.memory_samples)
        
        return memory_mb
    
    def run(self):
        """Execute dry-run."""
        logger.info("=" * 80)
        logger.info("WTNPS TRADE - DRY-RUN TEST")
        logger.info("=" * 80)
        logger.info(f"Ticker: {self.ticker}")
        logger.info(f"Timeframe: {self.timeframe}")
        logger.info(f"Duration: {self.duration_minutes} minutes")
        logger.info("=" * 80)
        
        self.start_time = datetime.now()
        
        try:
            # Initialize MonitorEngine
            logger.info("Initializing MonitorEngine...")
            monitor = RealTimeMonitor(
                ticker=self.ticker,
                timeframe_str=self.timeframe,
                ui_callback=self.signal_callback
            )
            logger.info("‚úÖ MonitorEngine initialized successfully")
            
            # Start monitoring in a separate thread
            import threading
            
            monitor_thread = threading.Thread(target=monitor.run, daemon=True)
            monitor_thread.start()
            logger.info("‚úÖ Monitoring started")
            
            # Run for specified duration
            duration_seconds = self.duration_minutes * 60
            elapsed = 0
            last_log_time = 0
            
            logger.info(f"Running for {self.duration_minutes} minutes...")
            
            while elapsed < duration_seconds:
                time.sleep(1)
                elapsed += 1
                
                # Monitor memory every 5 seconds
                if elapsed % 5 == 0:
                    memory_mb = self.monitor_memory()
                    
                # Log progress every 30 seconds
                if elapsed - last_log_time >= 30:
                    remaining = duration_seconds - elapsed
                    memory_mb = self.monitor_memory()
                    logger.info(
                        f"Progress: {elapsed}s / {duration_seconds}s | "
                        f"Signals: {self.signals_generated} | "
                        f"Memory: {memory_mb:.1f} MB | "
                        f"Remaining: {remaining}s"
                    )
                    last_log_time = elapsed
            
            # Stop monitor
            monitor.stop()
            logger.info("‚úÖ Monitor stopped")
            
            self.end_time = datetime.now()
            
            # Generate report
            self._generate_report()
            
        except KeyboardInterrupt:
            logger.warning("\n‚ö†Ô∏è  Dry-run interrupted by user")
            self.end_time = datetime.now()
            self._generate_report()
            return False
            
        except Exception as e:
            logger.error(f"‚ùå EXCEPTION DURING DRY-RUN: {e}", exc_info=True)
            self.exceptions_count += 1
            self.end_time = datetime.now()
            self._generate_report()
            return False
        
        return True
    
    def _generate_report(self):
        """Generate dry-run report."""
        logger.info("\n" + "=" * 80)
        logger.info("DRY-RUN REPORT")
        logger.info("=" * 80)
        
        duration = (self.end_time - self.start_time).total_seconds()
        
        logger.info(f"Start Time: {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info(f"End Time: {self.end_time.strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info(f"Duration: {duration:.1f} seconds ({duration/60:.1f} minutes)")
        logger.info("")
        logger.info(f"Signals Generated: {self.signals_generated}")
        logger.info(f"Exceptions: {self.exceptions_count}")
        logger.info("")
        logger.info(f"Max Memory: {self.max_memory_mb:.1f} MB")
        logger.info(f"Avg Memory: {self.avg_memory_mb:.1f} MB")
        logger.info("")
        
        # Determine pass/fail
        passed = True
        
        if self.exceptions_count > 0:
            logger.error("‚ùå FAIL: Exceptions occurred during dry-run")
            passed = False
        
        if self.max_memory_mb > 500:
            logger.warning(f"‚ö†Ô∏è  WARNING: Memory usage exceeded 500MB ({self.max_memory_mb:.1f} MB)")
        
        if self.signals_generated == 0:
            logger.warning("‚ö†Ô∏è  WARNING: No signals generated (market may be closed)")
        
        if passed:
            logger.info("‚úÖ PASS: Dry-run completed successfully")
        else:
            logger.error("‚ùå FAIL: Dry-run completed with errors")
        
        logger.info("=" * 80)
        logger.info(f"Full logs saved to: {self.log_path}")
        logger.info("=" * 80)
        
        return passed


def parse_args():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Dry-run test for WTNPS Trade Live Monitor"
    )
    
    parser.add_argument(
        "--ticker",
        type=str,
        default="WDO$",
        help="Asset ticker (default: WDO$)"
    )
    
    parser.add_argument(
        "--timeframe",
        type=str,
        default="M5",
        help="Timeframe (default: M5)"
    )
    
    parser.add_argument(
        "--duration",
        type=int,
        default=5,
        help="Duration in minutes (default: 5)"
    )
    
    return parser.parse_args()


def main():
    """Main entry point."""
    args = parse_args()
    
    dry_run = DryRunMonitor(
        ticker=args.ticker,
        timeframe=args.timeframe,
        duration_minutes=args.duration
    )
    
    success = dry_run.run()
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
